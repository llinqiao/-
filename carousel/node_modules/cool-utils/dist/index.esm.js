import axios$1 from 'axios';
import { pickBy, differenceWith, isEqual, debounce as debounce$1, throttle as throttle$1, omitBy, isEmpty } from 'lodash-es';
import clsnames from 'classnames';
import React, { useRef, useEffect, useReducer, useCallback } from 'react';
import URLSearchParams from 'url-search-params';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var STATUS_MESSAGE = {
  200: '服务器成功返回请求的数据。',
  201: '新建或修改数据成功。',
  202: '一个请求已经进入后台排队（异步任务）。',
  204: '删除数据成功。',
  400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。',
  401: '用户没有权限（令牌、用户名、密码错误）。',
  403: '用户得到授权，但是访问是被禁止的。',
  404: '发出的请求针对的是不存在的记录，服务器没有进行操作。',
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  422: '当创建一个对象时，发生一个验证错误。',
  500: '服务器发生错误，请检查服务器。',
  502: '网关错误。',
  503: '服务不可用，服务器暂时过载或维护。',
  504: '网关超时。'
};
var options = {
  statusMessage: STATUS_MESSAGE,
  // xsrf
  isXsrfOn: false,
  xsrfToken: undefined,
  xsrfConfig: {
    url: '',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    getToken: function getToken(token) {
      return token;
    },
    timeout: 10 * 60 * 1000
  },
  // exception
  correctErrorCode: 200,
  notLoginErrorCode: /1005/,
  loginPage: '/login',
  parseResponse: function parseResponse(data) {
    return data === null || data === void 0 ? void 0 : data.data;
  },
  throwError: {
    get: false,
    post: true,
    form: true,
    put: true,
    delete: true
  },
  // hook
  errorHook: undefined,
  notLoginHook: undefined
};

var setAxiosOptions = function setAxiosOptions() {
  var options$1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var passedInAxios = arguments.length > 1 ? arguments[1] : undefined;
  var axios$1 = passedInAxios || axios;
  axios$1.defaults.options = _objectSpread2(_objectSpread2({}, _typeof(axios$1.defaults.options) === 'object' ? axios$1.defaults.options : options), options$1);
};

var dataInterceptor = (function (axios) {
  axios.interceptors.request.use(function (config) {
    var method = config.method;

    if (method === 'get') {
      var params = config.params,
          data = config.data;
      config.params = _objectSpread2(_objectSpread2({}, data), params);
      config.data = {};
    }

    return config;
  }, function (error) {
    return Promise.reject(error);
  });
});

var omitNil = function omitNil(obj) {
  return pickBy(obj, function (value) {
    return value !== undefined && value !== null;
  });
};

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an String, otherwise false
 */
function isString(val) {
  return toString.call(val) === '[object String]';
}

var omitNilInterceptor = (function (axios) {
  axios.interceptors.request.use(function (config) {
    var params = config.params,
        data = config.data;

    if (isFormData(data) || isArray(data) || isString(data)) {
      return config;
    }

    config.params = omitNil(params);
    config.data = omitNil(data);
    return config;
  }, function (error) {
    return Promise.reject(error);
  });
});

var replacePlaceholder = function replacePlaceholder() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var regex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /:\w+/g;
  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var placeholders = string.match(regex);

  if (!placeholders) {
    return {
      string: string,
      data: data
    };
  }

  var newString = string;
  var newData = {};

  if (isFormData(data)) {
    data.forEach(function (value, key) {
      newData[key] = value;
    });
  } else {
    newData = _objectSpread2({}, data);
  }

  placeholders.forEach(function (placeholder) {
    var key = placeholder.substr(1);

    if (newData[key]) {
      newString = newString.replace(placeholder, newData[key]);
      delete newData[key];
    } else {
      console.error("missing '".concat(placeholder, "' data in string!"));
    }
  });
  return {
    string: newString,
    data: newData
  };
};

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && _typeof(val) === 'object';
}

var placeholderInterceptor = (function (axios) {
  axios.interceptors.request.use(function (config) {
    var url = config.url,
        params = config.params,
        data = config.data;

    if (isArray(data) || isString(data)) {
      return config;
    }

    if (isFormData(data)) {
      var _replacePlaceholder = replacePlaceholder(url, /:\w+/g, data);

      url = _replacePlaceholder.string;
      return _objectSpread2(_objectSpread2({}, config), {}, {
        url: url
      });
    }

    if (isObject(params)) {
      var _replacePlaceholder2 = replacePlaceholder(url, /:\w+/g, params);

      url = _replacePlaceholder2.string;
      params = _replacePlaceholder2.data;
    }

    if (isObject(data)) {
      var _replacePlaceholder3 = replacePlaceholder(url, /:\w+/g, data);

      url = _replacePlaceholder3.string;
      data = _replacePlaceholder3.data;
    }

    return _objectSpread2(_objectSpread2({}, config), {}, {
      url: url,
      params: params,
      data: data
    });
  }, function (error) {
    return Promise.reject(error);
  });
});

var xsrfInterceptor = (function (axios) {
  axios.interceptors.request.use( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config) {
      var options, method, xsrfToken, xsrfConfig, url, xsrfHeaderName, getToken, _xsrfConfig$timeout, timeout, setXsrfHeader, newXsrfToken;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = axios.defaults.options;
              method = config.method;

              if (!(!options.isXsrfOn || ['get', 'head'].includes((method || 'NO_FOUND').toLowerCase()))) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", config);

            case 4:
              xsrfToken = options.xsrfToken, xsrfConfig = options.xsrfConfig;
              url = xsrfConfig.url, xsrfHeaderName = xsrfConfig.xsrfHeaderName, getToken = xsrfConfig.getToken, _xsrfConfig$timeout = xsrfConfig.timeout, timeout = _xsrfConfig$timeout === void 0 ? 0 : _xsrfConfig$timeout;

              setXsrfHeader = function setXsrfHeader(_xsrfToken) {
                config.xsrfToken = _xsrfToken;
                config.headers[xsrfHeaderName || 'xsrf-token'] = _xsrfToken;
              };

              if (!config.xsrfToken) {
                _context.next = 10;
                break;
              }

              setXsrfHeader(config.xsrfToken);
              return _context.abrupt("return", config);

            case 10:
              if (!xsrfToken) {
                _context.next = 13;
                break;
              }

              setXsrfHeader(xsrfToken);
              return _context.abrupt("return", config);

            case 13:
              if (!(!getToken || !url)) {
                _context.next = 15;
                break;
              }

              return _context.abrupt("return", Promise.reject(new Error('Neithor xsrf token found nor url for getting new xsrf token provide.')));

            case 15:
              _context.t0 = getToken;
              _context.next = 18;
              return axios.get(url);

            case 18:
              _context.t1 = _context.sent;
              newXsrfToken = (0, _context.t0)(_context.t1);

              if (newXsrfToken) {
                _context.next = 22;
                break;
              }

              throw new Error('XSRF Not EXIST!');

            case 22:
              setXsrfHeader(newXsrfToken);

              if (timeout !== null && timeout > 0) {
                setTimeout(function () {
                  config.xsrfToken = undefined;
                }, timeout);
              }

              return _context.abrupt("return", config);

            case 25:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), function (error) {
    return Promise.reject(error);
  });
});

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

var adjustToPage = function adjustToPage(totalCount, pageSize, toPage) {
  if (totalCount - pageSize * (toPage - 1) === 1 && toPage > 1) {
    return toPage - 1;
  }

  return toPage;
};

var getEventHandler = function getEventHandler(conf, _this, orgFn) {
  var isCalled = false;
  return function () {
    if (conf.once && isCalled) {
      return;
    } else {
      isCalled = true;
    }

    var eventIndex = Math.max(0, Math.floor(conf.eventIndex || 0));

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var event = args[eventIndex];

    if (event) {
      if (conf.trimEvent && event.target) {
        if ('value' in event.target) {
          args[eventIndex] = event.target.value;
        } else if ('checked' in event.target) {
          args[eventIndex] = event.target.checked;
        }
      }

      if (conf.stop && event.stopPropagation) {
        event.stopPropagation();
      }

      if (conf.prevent && event.preventDefault) {
        event.preventDefault();
      }
    }

    return orgFn.apply(_this, args);
  };
};

var S_BINDED = Symbol('binded');
/**
 * 给对象的方法，绑定到this，是的将方法当做参数传递时，可以解决this引用的问题
 */

var bind = function bind(eventHandlerConf) {
  return function (target, fieldKey, desc) {
    var orgFn = desc.value;
    delete desc.value;
    delete desc.writable;

    desc.get = function () {
      var _this2 = this;

      if (!this[S_BINDED]) {
        this[S_BINDED] = {};
      }

      if (!this[S_BINDED][fieldKey]) {
        var fn = function fn() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return orgFn.apply(_this2, args);
        };

        if (eventHandlerConf) {
          fn.handler = getEventHandler(eventHandlerConf, this, orgFn);
        }

        this[S_BINDED][fieldKey] = fn;
      }

      return this[S_BINDED][fieldKey];
    };
  };
};

bind.handler = function (handler, arg) {
  var fn = handler && handler.handler || handler;

  if (arg === undefined || !handler) {
    return fn;
  }

  var argKey = "__argHandler__".concat(arg);

  if (!handler[argKey]) {
    handler[argKey] = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      args.unshift(arg);
      return fn.apply(this, args);
    };
  }

  return handler[argKey];
};

var classnames = function classnames(styles, _prefix) {
  var prefix = _prefix || styles.prefix;
  var cx = clsnames.bind(styles);
  if (!prefix) return cx;

  var handlePrefix = function handlePrefix(name) {
    if (name.startsWith(':')) return name.replace(':', '');
    return "".concat(prefix, "-").concat(name);
  };

  return function () {
    for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
      names[_key] = arguments[_key];
    }

    return cx(names.map(function (name) {
      if (typeof name === 'string') {
        return handlePrefix(name);
      }

      if (_typeof(name) === 'object') {
        var returnObj = {};
        Object.keys(name).forEach(function (key) {
          var element = name[key];
          returnObj[handlePrefix(key)] = element;
        });
        return returnObj;
      }

      return '';
    }));
  };
};

var getConsole2 = function getConsole2(checkDevEnv) {
  var console2 = {};
  Object.keys(console).forEach(function (key) {
    console2[key] = function () {
      if (checkDevEnv()) {
        var _console;

        (_console = console)[key].apply(_console, arguments);
      }
    };
  });
  return console2;
};

var console2 = getConsole2(function () {
  return !!(window && window.env && window.env.toLowerCase() === 'dev');
});

/* eslint-disable no-multi-assign */
var iframeId = "print-iframe-".concat(Date.now());
/**
* 打印一张图片
* @param src 图片的地址
* @param title 打印的标题
*/

var printImg = function printImg(src, title) {
  var iframeElm = document.getElementById(iframeId);

  if (!iframeElm) {
    iframeElm = document.createElement('iframe');
    document.body.appendChild(iframeElm);
    iframeElm.id = iframeId;
    iframeElm.style.cssText = 'border:0;position:absolute;width:0px;height:0px;right:0px;top:0px;';
  }

  iframeElm.onload = function () {
    if (!iframeElm.contentDocument) {
      return;
    }

    if (title) {
      iframeElm.contentDocument.title = title;
    }

    iframeElm.contentDocument.body.innerHTML = "<img src=\"".concat(src, "\" onload=\"window.print()\"/>");
  };

  iframeElm.src = 'about:blank';
};
var downloadLinkId = "download-link-".concat(Date.now());
/**
* 下载一个文件
* @param src 要下载内容的src
* @param filename 下载的文件名
*/

var downloadFile = function downloadFile(src, filename) {
  var linkElm = document.getElementById(downloadLinkId);

  if (!linkElm) {
    linkElm = document.createElement('a');
    document.body.appendChild(linkElm);
    linkElm.id = downloadLinkId;
    linkElm.style.cssText = 'position:absolute;width:0px;height:0px;right:0px;top:0px;overflow:hidden';
  }

  var blobUrl = '';

  if (typeof src === 'string') {
    linkElm.href = src;
  } else {
    var blob = new Blob([src], {
      type: 'application/octe-stream'
    });
    blobUrl = window.URL.createObjectURL(blob);
    linkElm.href = blobUrl;
  }

  if (filename) {
    linkElm.download = filename;
  }

  linkElm.click();

  if (blobUrl) {
    window.URL.revokeObjectURL(blobUrl);
  }
};
/**
* 通过post，打开一个新的窗口，并传递数据
* @param src 目标地址
* @param data 数据
* @param options.target 新窗口的target
* @param options.name 参数字段的key
*/

var postPage = function postPage(src, data) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    target: '_blank',
    name: 'name'
  };
  var temp_form = document.createElement('form');
  temp_form.id = 'exportGraphData_form';
  temp_form.action = src;
  temp_form.target = options.target;
  temp_form.method = 'post';
  temp_form.style.display = 'none';
  var opt = document.createElement('textarea');
  opt.name = 'data';
  opt.value = JSON.stringify(data);
  temp_form.appendChild(opt);
  document.body.appendChild(temp_form);
  temp_form.submit();
  setTimeout(function () {
    var form = document.getElementById('exportGraphData_form');
    form.remove();
  }, 2000);
};
var doc = document;
var fullScreen = {
  get enable() {
    if ('webkitFullscreenEnabled' in doc) {
      return doc.webkitFullscreenEnabled;
    }

    if ('fullscreenEnabled' in doc) {
      return doc.fullscreenEnabled;
    }

    return false;
  },

  get element() {
    if ('webkitFullscreenElement' in doc) {
      return doc.webkitFullscreenElement;
    }

    if ('fullscreenElement' in doc) {
      return doc.fullscreenElement;
    }

    return null;
  },

  get isFullScreen() {
    if ('webkitIsFullScreen' in doc) {
      return doc.webkitIsFullScreen;
    }

    if ('fullscreen' in doc) {
      return doc.fullscreen;
    }

    return false;
  },

  toggleFullScreen: function toggleFullScreen() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;

    if (this.isFullScreen) {
      this.cancelFullScreen();
    } else {
      this.requestFullScreen(element);
    }
  },
  requestFullScreen: function requestFullScreen() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;
    if (!element || !this.enable || this.isFullScreen) return;
    var el = element;

    if (el.requestFullscreen) {
      el.requestFullscreen();
    } else if (el.mozRequestFullScreen) {
      el.mozRequestFullScreen();
    } else if (el.webkitRequestFullScreen) {
      el.webkitRequestFullScreen();
    }
  },
  cancelFullScreen: function cancelFullScreen() {
    if (!this.enable || !this.isFullScreen) return;

    if (doc.exitFullscreen) {
      doc.exitFullscreen();
    } else if (doc.mozCancelFullScreen) {
      doc.mozCancelFullScreen();
    } else if (doc.webkitCancelFullScreen) {
      doc.webkitCancelFullScreen();
    }
  },
  onChange: function onChange(handler) {
    document.addEventListener('fullscreenchange', handler);
  },
  unChange: function unChange(handler) {
    document.removeEventListener('fullscreenchange', handler);
  }
};

function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return obj;
  }

  var newObj; // Force an array if not already something iterable

  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    newObj = [obj];
  }

  if (isArray(obj)) {
    newObj = []; // Iterate over array values

    for (var i = 0, l = obj.length; i < l; i += 1) {
      newObj[i] = fn.call(null, obj[i], i, obj);
    }
  } else {
    newObj = {}; // Iterate over object keys
    // eslint-disable-next-line no-unused-vars

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = fn.call(null, obj[key], key, obj);
      }
    }
  }

  return newObj;
}

function getDifferentiation(val, prevVal) {
  var added = differenceWith(val, prevVal, isEqual);
  var removed = differenceWith(prevVal, val, isEqual);
  return {
    added: added,
    removed: removed
  };
}

var highlightText = function highlightText(_ref) {
  var _ref$text = _ref.text,
      text = _ref$text === void 0 ? '' : _ref$text,
      _ref$highlightText = _ref.highlightText,
      highlightText = _ref$highlightText === void 0 ? '' : _ref$highlightText,
      _ref$regExpOption = _ref.regExpOption,
      regExpOption = _ref$regExpOption === void 0 ? 'gi' : _ref$regExpOption,
      _ref$highlightClassNa = _ref.highlightClassName,
      highlightClassName = _ref$highlightClassNa === void 0 ? '' : _ref$highlightClassNa,
      _ref$normalClassName = _ref.normalClassName,
      normalClassName = _ref$normalClassName === void 0 ? '' : _ref$normalClassName;
  var regExp = new RegExp(highlightText, regExpOption);
  var textArr = text.split(regExp);
  var elementArr = [];
  var key = 0;
  textArr.forEach(function (item, index) {
    elementArr.push( /*#__PURE__*/React.createElement("span", {
      key: key,
      className: normalClassName
    }, item));
    key += 1;

    if (index < textArr.length - 1) {
      elementArr.push( /*#__PURE__*/React.createElement("span", {
        key: key,
        className: highlightClassName
      }, highlightText));
      key += 1;
    }
  });
  return elementArr;
};

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */

function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

var UA = navigator.userAgent || '';
var OS = null;
/**
 * 判断常用的控制键，是否按下
 * Mac下是Command键，windows下是ctrl键
 * @param e 事件
 */

var isCtrlMetaPress = function isCtrlMetaPress(e) {
  if (!e) return false;

  if (getOS() === 'Mac') {
    return e.metaKey;
  }

  return e.ctrlKey;
};
var ctrlMetaToString = function ctrlMetaToString() {
  if (getOS() === 'Mac') {
    return 'Command';
  } else {
    return 'Ctrl';
  }
};
/**返回当前的操作系统 */

var getOS = function getOS() {
  if (OS) return OS;

  if (UA.indexOf('Window') > 0) {
    OS = 'Windows';
  } else if (UA.indexOf('Mac OS X') > 0) {
    OS = 'Mac';
  } else if (UA.indexOf('Linux') > 0) {
    OS = 'Linux';
  } else {
    OS = 'Other';
  }

  return OS;
};

var KEY_SHIFT_MAP = {
  '{': '[',
  '}': ']',
  '|': '\\',
  ';': ':',
  '"': '\'',
  '<': ',',
  '>': '.',
  '?': '/',
  '~': '`',
  _: '-',
  '+': '=',
  '!': '1',
  '@': '2',
  '#': '3',
  $: '4',
  '%': '5',
  '^': '6',
  '&': '7',
  '*': '8',
  '(': '9',
  ')': '0',
  ' ': 'space'
};
var INPUT_TYPE_WRITE_LIST = new Set(['radio', 'button', 'submit', 'reset']);

var KeyHandler = /*#__PURE__*/function () {
  function KeyHandler() {
    var _this = this;

    _classCallCheck(this, KeyHandler);

    this.listeners = new Set();

    this.handler = function (evt) {
      if (evt.target) {
        if (evt.target instanceof HTMLTextAreaElement || evt.target.isContentEditable) {
          return;
        }

        if (evt.target instanceof HTMLInputElement) {
          if (!INPUT_TYPE_WRITE_LIST.has(evt.target.type)) {
            return;
          }
        }
      }

      _this.listeners.forEach(function (listener) {
        return listener(evt);
      });
    };
  }

  _createClass(KeyHandler, [{
    key: "addEventListener",
    value: function addEventListener(listener) {
      this.listeners.add(listener);
      return this;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(listener) {
      this.listeners.delete(listener);
      return this;
    }
  }]);

  return KeyHandler;
}();

var isMatchKey = function isMatchKey(key, evt) {
  var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var evtKey = evt.key.toLowerCase();
  evtKey = KEY_SHIFT_MAP[evtKey] || evtKey;

  if (evtKey !== key) {
    return false;
  }

  if (!!option.alt !== evt.altKey || !!option.shift !== evt.shiftKey || !!option.ctrlMeta !== isCtrlMetaPress(evt)) {
    return false;
  }

  if (!option.ctrlMeta && (!!option.ctrl !== evt.ctrlKey || !!option.meta !== evt.metaKey)) return false;
  return true;
};
var handlers = {};

var getHandler = function getHandler(type) {
  var h = handlers[type];

  if (h) {
    return h;
  }

  h = new KeyHandler();
  handlers[type] = h;
  document.body.addEventListener(type, h.handler);
  return h;
};

var keyboardMan = {
  get up() {
    return getHandler('keyup');
  },

  get down() {
    return getHandler('keydown');
  },

  get press() {
    return getHandler('keypress');
  }

};

var getJS = function getJS(url) {
  return new Promise(function (resolve, reject) {
    if (!url) {
      resolve('empty url');
    }

    var scripts = Array.from(document.getElementsByTagName('script'));

    if (scripts.find(function (script) {
      return script.src === url;
    })) {
      resolve("duplicate: ".concat(url));
      return;
    }

    var script = document.createElement('script');
    script.type = 'text/javascript';

    if (script.readyState) {
      //IE
      script.onreadystatechange = function () {
        if (script.readyState === 'loaded' || script.readyState === 'complete') {
          script.onreadystatechange = function () {};

          resolve("success: ".concat(url));
        }
      };
    } else {
      //Others
      script.onload = function () {
        resolve("success: ".concat(url));
      };
    }

    script.onerror = function () {
      reject(Error("".concat(url, ": load error!")));
    };

    script.src = url;
    document.body.appendChild(script);
  });
};
/*
 * url param example:
 * 'url.js' --> will only load url.js
 * ['url1.js', 'url2.js'] --> will load url1.js first, then url2.js
 * [['url1.js', 'url2.js'], 'url3.js'] --> will load url1.js and url2.js in parallel,
 *                                         and then url3.js
 */

var loadScripts = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url, callback) {
    var _iterator, _step, currentValue;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (url) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return");

          case 2:
            if (!Array.isArray(url)) {
              _context.next = 28;
              break;
            }

            _iterator = _createForOfIteratorHelper(url);
            _context.prev = 4;

            _iterator.s();

          case 6:
            if ((_step = _iterator.n()).done) {
              _context.next = 18;
              break;
            }

            currentValue = _step.value;

            if (!Array.isArray(currentValue)) {
              _context.next = 13;
              break;
            }

            _context.next = 11;
            return Promise.all(currentValue.map(function (value) {
              return getJS(value);
            }));

          case 11:
            _context.next = 16;
            break;

          case 13:
            if (!currentValue) {
              _context.next = 16;
              break;
            }

            _context.next = 16;
            return getJS(currentValue);

          case 16:
            _context.next = 6;
            break;

          case 18:
            _context.next = 23;
            break;

          case 20:
            _context.prev = 20;
            _context.t0 = _context["catch"](4);

            _iterator.e(_context.t0);

          case 23:
            _context.prev = 23;

            _iterator.f();

            return _context.finish(23);

          case 26:
            _context.next = 30;
            break;

          case 28:
            _context.next = 30;
            return getJS(url);

          case 30:
            if (callback) {
              callback();
            }

          case 31:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 20, 23, 26]]);
  }));

  return function loadScripts(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var getStyle = function getStyle(url) {
  var links = Array.from(document.getElementsByTagName('link'));

  if (links.find(function (link) {
    return link.href === url;
  })) {
    return;
  }

  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = url;
  document.head.appendChild(link);
};
var loadStyles = function loadStyles(url) {
  if (!url) {
    return;
  }

  if (Array.isArray(url)) {
    url.forEach(function (value) {
      getStyle(value);
    });
  } else {
    getStyle(url);
  }
};

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */

function merge() {
  var result = {};

  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && _typeof(val) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  args.forEach(function (arg) {
    forEach(arg, assignValue);
  });
  return result;
}

function objectToFormData(obj, form, namespace) {
  var fd = form || new FormData();
  var formKey; // eslint-disable-next-line no-unused-vars

  for (var property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      if (namespace) {
        formKey = namespace + Array.isArray(obj) ? '[]' : "[".concat(property, "]");
      } else {
        formKey = property;
      }

      var value = obj[property]; // if the property is an object, but not a File, use recursivity.

      if (isObject(value) && !isFile(value) && !isBlob(value)) {
        objectToFormData(value, fd, formKey);
      } else {
        // if it's a string or a File object
        fd.append(formKey, value);
      }
    }
  }

  return fd;
}

var stringToDomElement = function stringToDomElement(html) {
  var wrapMapTable = [1, '<table>', '</table>'];
  var wrapMapOption = [1, "<select multiple='multiple'>", '</select>'];
  var wrapMapTr = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
  var wrapMap = {
    option: wrapMapOption,
    optgroup: wrapMapOption,
    legend: [1, '<fieldset>', '</fieldset>'],
    area: [1, '<map>', '</map>'],
    param: [1, '<object>', '</object>'],
    thead: wrapMapTable,
    tbody: wrapMapTable,
    tfoot: wrapMapTable,
    colgroup: wrapMapTable,
    caption: wrapMapTable,
    tr: [2, '<table><tbody>', '</tbody></table>'],
    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
    td: wrapMapTr,
    th: wrapMapTr,
    body: [0, '', ''],
    default: [1, '<div>', '</div>']
  };
  var match = /<\s*\w.*?>/g.exec(html);
  var element = document.createElement('div');

  if (match != null) {
    var tag = match[0].replace(/</g, '').replace(/>/g, '').split(' ')[0];

    if (tag.toLowerCase() === 'body') {
      var _element$firstChild;

      // const dom = document.implementation.createDocument(
      //   'http://www.w3.org/1999/xhtml',
      //   'html',
      //   null,
      // );
      var body = document.createElement('body'); // keeping the attributes

      element.innerHTML = html.replace(/<body/g, '<div').replace(/<\/body>/g, '</div>');
      var attrs = ((_element$firstChild = element.firstChild) === null || _element$firstChild === void 0 ? void 0 : _element$firstChild.attributes) || [];
      body.innerHTML = html;

      for (var i = 0; i < attrs.length; i++) {
        body.setAttribute(attrs[i].name, attrs[i].value);
      }

      return body;
    }

    var map = wrapMap[tag] || wrapMap.default;
    element.innerHTML = map[1] + html + map[2]; // Descend through wrappers to the right content

    var j = map[0] + 1;
    /* eslint no-plusplus:0 */

    while (j--) {
      element = element.lastChild;
    }
  } else {
    element.innerHTML = html;
    element = element.lastChild;
  }

  return element;
};

/**
 * 给指定url，添加参数
 * @param url 目标url
 * @param paramsObj 要添加的参数对象
 * @return 操作后的url
 */
var urlAddParams = function urlAddParams(url, paramsObj) {
  var urlSp = url.split('?');
  var oldParams = urlSp[1] ? urlParseParams(urlSp[1]) : {};
  var paramsString = objToParams(Object.assign(oldParams, paramsObj));
  return paramsString ? "".concat(urlSp[0], "?").concat(paramsString) : url;
};
/**
 * 解析url的search部分为对象
 * @param params url的search部分，如a=10&b=abc
 * @returns  `{[key:string]:string}` 转换后的对象
 */

var urlParseParams = function urlParseParams(params) {
  var ret = {};

  if (params && params.length) {
    var paramsStr = params.includes('?') ? params.split('?')[1] : params;
    var sp = paramsStr.split('&');

    for (var i = 0; i < sp.length; i++) {
      var kv = sp[i];
      if (!kv.length) continue;
      var kvSp = kv.split('=');
      ret[kvSp[0]] = kvSp[1] === undefined ? '' : decodeURIComponent(kvSp[1]);
    }
  }

  return ret;
};
/**
 * 将对象转换为url的search部分
 * number string boolean类型的值转换为字符串，其他的调用JSON.stringify尝试转换。并对结果进行encodeURIComponent
 * @param obj 要转换的对象
 * @returns 结果的字符串
 */

var objToParams = function objToParams(obj) {
  if (!obj) return '';
  var ret = [];

  for (var key in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, key)) {
      continue;
    }

    var value = obj[key];

    var typeofKey = _typeof(obj[key]);

    var paramValue = void 0;

    if (typeofKey === 'number' || typeofKey === 'string' || typeofKey === 'boolean') {
      paramValue = value;
    } else {
      paramValue = JSON.stringify(value);
    }

    if (paramValue === undefined || value === null) {
      paramValue = '';
    } else {
      paramValue = encodeURIComponent(paramValue);
    }

    ret.push("".concat(key, "=").concat(paramValue));
  }

  return ret.join('&');
};

/**
 * 对lodash防抖函数的装饰器封装
 * @param wait 需要延迟的毫秒数
 * @param options 选项对象
 */

var debounce = function debounce(wait, options) {
  return function (_target, _propertyKey, descriptor) {
    // eslint-disable-next-line no-param-reassign
    descriptor.value = debounce$1(descriptor.value, wait, options);
  };
};

/**
 * 对lodash节流函数的装饰器封装
 * @param wait 需要延迟的毫秒数
 * @param options 选项对象
 */

var throttle = function throttle(wait, options) {
  return function (_target, _name, descriptor) {
    // eslint-disable-next-line no-param-reassign
    descriptor.value = throttle$1(descriptor.value, wait, options);
  };
};

var jsonp = function jsonp(url) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var reqId = "jsonc_".concat(Math.round(Math.random() * 10000000).toString(26));

  var extraParams = _defineProperty({}, options.callbackKey || 'callback', reqId);

  var finalParams = params ? Object.assign({}, params, extraParams) : extraParams;
  var finalUrl = urlAddParams(url, finalParams);
  var scriptElm = document.createElement('script');
  document.body.appendChild(scriptElm);
  scriptElm.setAttribute('type', 'text/javascript');

  if (options.charset) {
    scriptElm.setAttribute('charset', options.charset);
  }

  scriptElm.async = true;
  scriptElm.setAttribute('src', finalUrl);
  var win = window;
  return new Promise(function (resolve, reject) {
    var handled = false;

    if (options.timeout) {
      window.setTimeout(function () {
        if (handled) return;
        handled = true;
        reject(new Error('JsonP timeout'));
        document.body.removeChild(scriptElm);
        delete win[reqId]; // @ts-ignore

        scriptElm = null;
      }, options.timeout);
    }

    win[reqId] = function (data) {
      if (handled) return;
      handled = true;

      document.body.removeChild(scriptElm);
      delete win[reqId]; // @ts-ignore

      scriptElm = null;
      resolve(data);
    };
  });
};

var getLoginPage = function getLoginPage(loginPage) {
  return "".concat(loginPage, "?redirectUrl=").concat(location.pathname).concat(location.search.substr(1) ? "&".concat(location.search.substr(1)) : '');
};

var checkLogin = (function (response, options) {
  var notLoginErrorCode = options.notLoginErrorCode,
      loginPage = options.loginPage;
  var _response$data = response.data,
      errorCode = _response$data.errorCode,
      errCode = _response$data.errCode,
      errorMsg = _response$data.errorMsg,
      errMsg = _response$data.errMsg,
      data = _response$data.data;

  var _ref = data || {},
      loginUrl = _ref.loginUrl;

  var eCode = errorCode || errCode || 0;

  if (notLoginErrorCode instanceof RegExp ? notLoginErrorCode.test(eCode) : notLoginErrorCode === eCode) {
    var eMsg = errorMsg || errMsg || 'Default not login error message!';
    return _objectSpread2({
      error: new Error(eMsg)
    }, loginPage === false ? {} : {
      loginPage: loginUrl || (isString(loginPage) ? getLoginPage(loginPage) : '')
    });
  }

  return {};
});

function toLoginPage(loginPageUrl) {
  window.location.href = loginPageUrl;
}

var notLoginInterceptor = (function (axios) {
  axios.interceptors.response.use(function (response) {
    var options = axios.defaults.options;

    var _checkLogin = checkLogin(response, options),
        loginPage = _checkLogin.loginPage,
        error = _checkLogin.error;

    if (error) {
      if (options.notLoginHook && isFunction(options.notLoginHook)) {
        return options.notLoginHook(response, options);
      }

      if (loginPage) {
        toLoginPage(loginPage);
        return response;
      } // eslint-disable-next-line prefer-promise-reject-errors


      return Promise.reject(_objectSpread2(_objectSpread2({}, response), error));
    }

    return response;
  }, function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  });
});

var errorInterceptor = (function (axios) {
  axios.interceptors.response.use(function (response) {
    var options = axios.defaults.options;
    var correctErrorCode = options.correctErrorCode;
    var _response$data = response.data,
        errorCode = _response$data.errorCode,
        errCode = _response$data.errCode,
        errorMsg = _response$data.errorMsg,
        errMsg = _response$data.errMsg;
    var eCode = errorCode || errCode || 0;

    if (!eCode || eCode === correctErrorCode) {
      return response;
    }

    var eMsg = errorMsg || errMsg || 'Default no defined error message!';
    var error = new Error(eMsg); // eslint-disable-next-line prefer-promise-reject-errors

    return Promise.reject(_objectSpread2(_objectSpread2({}, response), error));
  }, function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  });
});

var parseResponse = (function (response, options) {
  var _ref = options || {},
      parseResponse = _ref.parseResponse;

  return isFunction(parseResponse) ? parseResponse(response.data) : response.data;
});

var responseInterceptor = (function (axios) {
  axios.interceptors.response.use(function (response) {
    return parseResponse(response, axios.defaults.options);
  }, function (error) {
    var options = axios.defaults.options;
    var _options$throwError = options.throwError,
        throwError = _options$throwError === void 0 ? false : _options$throwError;
    var request = error.request,
        config = error.config,
        response = error.response;

    var _ref = config || request || {},
        method = _ref.method;

    if (_typeof(throwError) === 'object' && method ? throwError[method] : throwError) {
      return Promise.reject(error);
    }

    return response;
  });
});

var getAxiosInstance = (function () {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var axiosInstance = axios$1.create(config); // set options in axios instance

  setAxiosOptions(undefined, axiosInstance); // request interceptors

  dataInterceptor(axiosInstance);
  omitNilInterceptor(axiosInstance);
  placeholderInterceptor(axiosInstance);
  xsrfInterceptor(axiosInstance); // response interceptors

  notLoginInterceptor(axiosInstance);
  errorInterceptor(axiosInstance);
  responseInterceptor(axiosInstance);
  return axiosInstance;
});

var axios = getAxiosInstance();

var addXRequestedWith = (function (options) {
  return _objectSpread2(_objectSpread2({}, options), {}, {
    headers: _objectSpread2(_objectSpread2({}, options.headers || {}), 'x-requested-with' in (options.headers || {}) ? {} : {
      'x-requested-with': 'XMLHttpRequest'
    })
  });
});

var processFormData = function processFormData(data, configData) {
  return isFormData(data) ? data : objectToFormData(_objectSpread2(_objectSpread2({}, data), configData || {}));
};

//   method: 'get' | 'post' | 'delete' | 'put' | 'form';
//   url: string;
//   data: any;
// }

function mergeDataOrParams(dp, configDP) {
  if (isString(dp) || isArray(dp)) {
    return configDP || dp;
  }

  return _objectSpread2(_objectSpread2({}, dp), configDP || {});
}

function request(options) {
  return axios(addXRequestedWith(options));
}
function get(api) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!api) {
    return undefined;
  }

  return request(isObject(api) ? _objectSpread2({
    method: 'get'
  }, api) : _objectSpread2(_objectSpread2({
    url: api,
    method: 'get',
    headers: headers
  }, config), {}, {
    params: mergeDataOrParams(params, config.params)
  }));
}
function post(api) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!api) {
    return undefined;
  }

  return request(isObject(api) ? _objectSpread2({
    method: 'post'
  }, api) : _objectSpread2(_objectSpread2({
    url: api,
    method: 'post',
    headers: headers
  }, config), {}, {
    data: mergeDataOrParams(data, config.data)
  }));
}
function deleteMethod(api) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!api) {
    return undefined;
  }

  return request(isObject(api) ? _objectSpread2({
    method: 'delete'
  }, api) : _objectSpread2(_objectSpread2({
    url: api,
    method: 'delete'
  }, config), {}, {
    data: mergeDataOrParams(data, config.data)
  }));
}
function put(api) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!api) {
    return undefined;
  }

  return request(isObject(api) ? _objectSpread2({
    method: 'put'
  }, api) : _objectSpread2(_objectSpread2({
    url: api,
    method: 'put'
  }, config), {}, {
    data: mergeDataOrParams(data, config.data)
  }));
}
function form(api) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!api) {
    return undefined;
  }

  return request(isObject(api) ? _objectSpread2(_objectSpread2({
    method: 'post'
  }, api), {}, {
    data: api.data ? processFormData(api.data) : undefined
  }) : _objectSpread2(_objectSpread2({
    url: api,
    method: 'post',
    headers: headers
  }, config), {}, {
    data: processFormData(data, config.data)
  }));
}
var axiosMethods = {
  get: get,
  post: post,
  delete: deleteMethod,
  put: put,
  form: form
};

var base = {};

function usePrevious(value, initValue) {
  var prevRef = useRef();
  var curRef = useRef(initValue);
  prevRef.current = curRef.current;
  curRef.current = value;
  return prevRef.current;
}

function useAdvancedCompare(vals) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$comparator = _ref.comparator,
      comparator = _ref$comparator === void 0 ? isEqual : _ref$comparator,
      callback = _ref.callback;

  if (!vals || vals.length === 0) {
    return false;
  }

  var prevVals = usePrevious(vals, vals.map(function () {
    return undefined;
  }));
  var isDifferent = !comparator(vals, prevVals);

  if (isDifferent && isFunction(callback)) {
    callback(vals);
  }

  return isDifferent;
}

function useCompare() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var callback = args[args.length - 1];
  var vals = typeof callback === 'function' ? args.slice(0, args.length - 1) : args;
  var prevVals = usePrevious(vals, vals.map(function () {
    return undefined;
  }));
  var isDifferent = !isEqual(prevVals, vals);

  if (isDifferent && typeof callback === 'function') {
    callback.apply(void 0, _toConsumableArray(vals));
  }

  return isDifferent;
}

function useDifferentiation(val) {
  var prevVal = usePrevious(val);
  var added = differenceWith(val, prevVal, isEqual);
  var removed = differenceWith(prevVal, val, isEqual);
  return {
    added: added,
    removed: removed
  };
}

function useEventListener(eventName, handler) {
  var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;
  // Create a ref that stores handler
  var savedHandler = useRef(console.log); // Update ref.current value if handler changes.
  // This allows our effect below to always get latest handler ...
  // ... without us needing to pass it in effect deps array ...
  // ... and potentially cause effect to re-run every render.

  useEffect(function () {
    savedHandler.current = handler;
  }, [handler]);
  useEffect(function () {
    // Make sure element supports addEventListener
    // On
    var isSupported = element && element.addEventListener;
    if (!isSupported) return; // Create event listener that calls handler function stored in ref

    var eventListener = function eventListener(event) {
      return savedHandler.current(event);
    }; // Add event listener


    element.addEventListener(eventName, eventListener); // Remove event listener on cleanup
    // eslint-disable-next-line consistent-return

    return function () {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

var initialState = {
  // Array of previous state values updated each time we push a new state
  past: [],
  // Current state value
  present: null,
  // Will contain "future" state values if we undo (so we can redo)
  future: []
}; // Our reducer function to handle state changes based on action

var reducer = function reducer(state, action) {
  var past = state.past,
      present = state.present,
      future = state.future;

  switch (action.type) {
    case 'UNDO':
      var previous = past[past.length - 1];
      var newPast = past.slice(0, past.length - 1);
      return {
        past: newPast,
        present: previous,
        future: [present].concat(_toConsumableArray(future))
      };

    case 'REDO':
      var next = future[0];
      var newFuture = future.slice(1);
      return {
        past: [].concat(_toConsumableArray(past), [present]),
        present: next,
        future: newFuture
      };

    case 'SET':
      var newPresent = action.newPresent;

      if (newPresent === present) {
        return state;
      }

      return {
        past: [].concat(_toConsumableArray(past), [present]),
        present: newPresent,
        future: []
      };

    case 'CLEAR':
      var initialPresent = action.initialPresent;
      return _objectSpread2(_objectSpread2({}, initialState), {}, {
        present: initialPresent
      });

    default:
      return {};
  }
};

function useHistory(initialPresent) {
  var _useReducer = useReducer(reducer, _objectSpread2(_objectSpread2({}, initialState), {}, {
    present: initialPresent
  })),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  var canUndo = state.past.length !== 0;
  var canRedo = state.future.length !== 0; // Setup our callback functions
  // We memoize with useCallback to prevent unnecessary re-renders

  var undo = useCallback(function () {
    if (canUndo) {
      dispatch({
        type: 'UNDO'
      });
    }
  }, [canUndo, dispatch]);
  var redo = useCallback(function () {
    if (canRedo) {
      dispatch({
        type: 'REDO'
      });
    }
  }, [canRedo, dispatch]);
  var set = useCallback(function (newPresent) {
    return dispatch({
      type: 'SET',
      newPresent: newPresent
    });
  }, [dispatch]);
  var clear = useCallback(function () {
    return dispatch({
      type: 'CLEAR',
      initialPresent: initialPresent
    });
  }, [initialPresent]); // If needed we could also return past and future state

  return {
    state: state.present,
    set: set,
    undo: undo,
    redo: redo,
    clear: clear,
    canUndo: canUndo,
    canRedo: canRedo
  };
}

function usePreviousProp(value, initValue) {
  var ref = useRef(initValue);
  useEffect(function () {
    ref.current = value;
  });
  return ref.current;
}

function useWhyDidYouUpdate(name, props) {
  // Get a mutable ref object where we can store props ...
  // ... for comparison next time this hook runs.
  var previousProps = useRef({});
  useEffect(function () {
    if (Object.keys(previousProps.current).length > 0) {
      // Get all keys from previous and current props
      var allKeys = Object.keys(_objectSpread2(_objectSpread2({}, previousProps.current), props)); // Use this object to keep track of changed props

      var changesObj = {}; // Iterate through keys

      allKeys.forEach(function (key) {
        // If previous is different from current
        if (previousProps.current[key] !== props[key]) {
          // Add to changesObj
          changesObj[key] = {
            from: previousProps.current[key],
            to: props[key]
          };
        }
      }); // If changesObj not empty then output to console

      if (Object.keys(changesObj).length > 0) {
        // eslint-disable-next-line no-console
        console.log('[why-did-you-update]', name, changesObj);
      }
    } // Finally update previousProps with current props for next hook call


    previousProps.current = props;
  });
}

var CODE_MESSAGE = {
  200: '服务器成功返回请求的数据。',
  201: '新建或修改数据成功。',
  202: '一个请求已经进入后台排队（异步任务）。',
  204: '删除数据成功。',
  400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。',
  401: '用户没有权限（令牌、用户名、密码错误）。',
  403: '用户得到授权，但是访问是被禁止的。',
  404: '发出的请求针对的是不存在的记录，服务器没有进行操作。',
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  422: '当创建一个对象时，发生一个验证错误。',
  500: '服务器发生错误，请检查服务器。',
  502: '网关错误。',
  503: '服务不可用，服务器暂时过载或维护。',
  504: '网关超时。'
};
var Http = /*#__PURE__*/function () {
  function Http() {
    _classCallCheck(this, Http);

    this.commonConfig = {
      csrf: false,
      headers: {},
      errorHook: function errorHook(error, url) {
        // eslint-disable-next-line no-console
        console.warn("Http Request Error in '".concat(url, "':"), error);
      },
      notLoginInErrorCode: /18003|18004/,
      notLoginInUrl: '/login',
      notLoginHook: undefined,
      notLoginCallback: function notLoginCallback(notLoginInUrl) {
        toLoginPage(notLoginInUrl);
      },
      isResultCheck: true,
      parseResult: function parseResult(data) {
        return data && data.data;
      },
      isGetParamJsonStringfy: false,
      throwError: {
        get: false,
        post: true,
        form: true,
        put: true,
        delete: true
      },
      correctErrorCode: 200,
      requestInterval: 0,
      requestTimeout: 0,
      fetchRetryTimes: 0,
      codeMessage: CODE_MESSAGE,
      urlPrefix: '',
      dataInterceptor: [function omitNil(data) {
        return omitBy(data, function isNil(value) {
          return value === undefined || value === null;
        });
      }],
      requestInterceptor: [],
      responseInterceptor: []
    };
    this.csrfToken = null;
    this.requestPromises = new Map();
    this.savedFetchRetryTimes = {};
  }

  _createClass(Http, [{
    key: "notLoginIn",
    value: function notLoginIn(loginPageUrl) {
      var urlReg = /^https?:\/\/*/;
      var _this$commonConfig = this.commonConfig,
          notLoginInUrl = _this$commonConfig.notLoginInUrl,
          notLoginCallback = _this$commonConfig.notLoginCallback,
          notLoginHook = _this$commonConfig.notLoginHook;

      if (isFunction(notLoginHook)) {
        notLoginHook();
        return;
      }

      if (loginPageUrl && urlReg.test(loginPageUrl)) {
        window.location.href = loginPageUrl;
        return;
      }

      if (!notLoginInUrl) {
        return;
      }

      if (urlReg.test(notLoginInUrl)) {
        window.location.href = "".concat(notLoginInUrl, "?redirectUrl=").concat(window.location.href);
      } else if (window.location.pathname !== notLoginInUrl && notLoginCallback) {
        notLoginCallback(notLoginInUrl);
      }
    }
  }, {
    key: "checkStatus",
    value: function checkStatus(response) {
      if (response.status === 200) {
        return response;
      }

      var error = new Error(response.statusText || this.commonConfig.codeMessage[response.status]);
      error.status = response.status;
      error.data = response;
      throw error;
    }
  }, {
    key: "checkErrCode",
    value: function checkErrCode(dataObj) {
      var data = dataObj.data,
          errorCode = dataObj.errorCode,
          errCode = dataObj.errCode,
          errorMsg = dataObj.errorMsg,
          errMsg = dataObj.errMsg,
          code = dataObj.code,
          msg = dataObj.msg;
      var eCode = errorCode || errCode || code || 0;
      var eMsg = errorMsg || errMsg || msg || 'No defined error message!';
      var _this$commonConfig2 = this.commonConfig,
          correctErrorCode = _this$commonConfig2.correctErrorCode,
          notLoginInErrorCode = _this$commonConfig2.notLoginInErrorCode;

      if (Number(eCode) === 0 || eCode === correctErrorCode) {
        return;
      }

      if (notLoginInErrorCode instanceof RegExp ? notLoginInErrorCode.test(eCode) : notLoginInErrorCode === eCode) {
        this.notLoginIn(eMsg);
        return;
      }

      var error = new Error(eMsg);
      error.data = data;
      error.errorCode = errorCode;
      error.errCode = errCode;
      throw error;
    }
  }, {
    key: "parseResult",
    value: function parseResult(data) {
      this.checkErrCode(data);
      return this.commonConfig.parseResult ? this.commonConfig.parseResult(data) : data;
    }
  }, {
    key: "processResult",
    value: function () {
      var _processResult = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(response) {
        var returnResponse;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.checkStatus(response);
                _context.next = 3;
                return response.json();

              case 3:
                returnResponse = _context.sent;

                if (this.commonConfig.isResultCheck) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", returnResponse);

              case 6:
                return _context.abrupt("return", this.parseResult(returnResponse));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function processResult(_x) {
        return _processResult.apply(this, arguments);
      }

      return processResult;
    }()
  }, {
    key: "getCsrfToken",
    value: function () {
      var _getCsrfToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this = this;

        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.commonConfig.csrf) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", undefined);

              case 2:
                if (this.csrfToken) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 5;
                return this.get(this.commonConfig.csrf.api);

              case 5:
                response = _context2.sent;

                if (this.commonConfig.csrf.parseToken) {
                  response = this.commonConfig.csrf.parseToken(response);
                }

                if (response) {
                  _context2.next = 9;
                  break;
                }

                throw new Error('CSRF Not EXIST!');

              case 9:
                // response is a object with attribute token
                this.csrfToken = response;
                setTimeout(function () {
                  _this.csrfToken = null;
                }, this.commonConfig.csrf.timeout || 11 * 60 * 1000);

              case 11:
                return _context2.abrupt("return", this.csrfToken);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getCsrfToken() {
        return _getCsrfToken.apply(this, arguments);
      }

      return getCsrfToken;
    }()
  }, {
    key: "objectToFormData",
    value: function objectToFormData(obj, form, namespace) {
      var fd = form || new FormData();
      var formKey; // eslint-disable-next-line no-unused-vars

      for (var property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
          if (namespace) {
            formKey = namespace + Array.isArray(obj) ? '[]' : "[".concat(property, "]");
          } else {
            formKey = property;
          } // if the property is an object, but not a File, use recursivity.


          if (_typeof(obj[property]) === 'object' && !(obj[property] instanceof File) && !(obj[property] instanceof Blob)) {
            this.objectToFormData(obj[property], fd, formKey);
          } else {
            // if it's a string or a File object
            fd.append(formKey, obj[property]);
          }
        }
      }

      return fd;
    }
  }, {
    key: "requestCache",
    value: function requestCache(url, customOptions) {
      var _this2 = this;

      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      var request = function request() {
        return _this2.request(url, customOptions, headers, config);
      };

      if (this.commonConfig.requestInterval <= 0) {
        return request();
      }

      var hash = "".concat(url, "-").concat(JSON.stringify(customOptions), "-").concat(JSON.stringify(headers), "-").concat(JSON.stringify(config));
      var o = this.requestPromises.get(hash);
      var now = Date.now();

      if (o && now - o.now < this.commonConfig.requestInterval) {
        return o.promise;
      }

      var output = {
        now: now,
        promise: request
      };
      this.requestPromises.set(hash, output);
      return request();
    }
  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_url, customOptions) {
        var headers,
            config,
            _this$commonConfig3,
            requestTimeout,
            fetchRetryTimes,
            throwError,
            urlPrefix,
            commonHeaders,
            url,
            requestInterceptor,
            responseInterceptor,
            options,
            originalResponse,
            response,
            processedResponse,
            thisUrlFetchRetryTimes,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                headers = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
                config = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};
                _this$commonConfig3 = this.commonConfig, requestTimeout = _this$commonConfig3.requestTimeout, fetchRetryTimes = _this$commonConfig3.fetchRetryTimes, throwError = _this$commonConfig3.throwError, urlPrefix = _this$commonConfig3.urlPrefix, commonHeaders = _this$commonConfig3.headers;
                url = "".concat(urlPrefix).concat(_url);
                requestInterceptor = [].concat(_toConsumableArray(this.commonConfig.requestInterceptor), _toConsumableArray(isArray(config.requestInterceptor) ? config.requestInterceptor : []));
                responseInterceptor = [].concat(_toConsumableArray(this.commonConfig.responseInterceptor), _toConsumableArray(isArray(config.responseInterceptor) ? config.responseInterceptor : []));
                options = requestInterceptor.reduce(function (accumulator, interceptor) {
                  return interceptor(accumulator);
                }, _objectSpread2(_objectSpread2({
                  credentials: 'include',
                  rejectUnauthorized: false
                }, customOptions), {}, {
                  headers: _objectSpread2(_objectSpread2(_objectSpread2({
                    'x-requested-with': 'XMLHttpRequest'
                  }, commonHeaders || {}), customOptions.headers || {}), headers || {})
                }));
                _context3.prev = 7;

                if (!(requestTimeout > 0)) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 11;
                return Promise.race([fetch(url, options), new Promise(function (resolve, reject) {
                  setTimeout(function () {
                    reject(new Error("Request ".concat(url, " timeout after ").concat(requestTimeout, "ms!!!")));
                  }, requestTimeout);
                })]);

              case 11:
                _context3.t0 = _context3.sent;
                _context3.next = 17;
                break;

              case 14:
                _context3.next = 16;
                return fetch(url, options);

              case 16:
                _context3.t0 = _context3.sent;

              case 17:
                originalResponse = _context3.t0;
                response = responseInterceptor.reduce(function (accumulator, interceptor) {
                  return interceptor(accumulator);
                }, originalResponse);
                _context3.next = 21;
                return this.processResult(response);

              case 21:
                processedResponse = _context3.sent;
                return _context3.abrupt("return", processedResponse);

              case 25:
                _context3.prev = 25;
                _context3.t1 = _context3["catch"](7);
                thisUrlFetchRetryTimes = this.savedFetchRetryTimes[url] || 1;

                if (!(thisUrlFetchRetryTimes > fetchRetryTimes)) {
                  _context3.next = 34;
                  break;
                }

                delete this.savedFetchRetryTimes[url];
                this.commonConfig.errorHook(_context3.t1, url);

                if (!(config.throwError !== false && (config.throwError || (_typeof(throwError) === 'object' ? throwError[(options.method || 'get').toLowerCase()] : throwError)))) {
                  _context3.next = 33;
                  break;
                }

                throw _context3.t1;

              case 33:
                return _context3.abrupt("return", null);

              case 34:
                this.savedFetchRetryTimes[url] = thisUrlFetchRetryTimes + 1;
                return _context3.abrupt("return", this.request(url, customOptions, headers, config));

              case 36:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[7, 25]]);
      }));

      function request(_x2, _x3) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "interceptData",
    value: function interceptData(_api, _data, config) {
      var _replacePlaceholder = replacePlaceholder(_api, /:\w+/g, _data),
          api = _replacePlaceholder.string,
          replacedData = _replacePlaceholder.data;

      var dataInterceptor = [].concat(_toConsumableArray(this.commonConfig.dataInterceptor), _toConsumableArray(isArray(config.dataInterceptor) ? config.dataInterceptor : []));
      var data = dataInterceptor.reduce(function (accumulator, interceptor) {
        return interceptor(accumulator);
      }, replacedData);
      return {
        api: api,
        data: data
      };
    }
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(getApi) {
        var getData,
            headers,
            config,
            _this$interceptData,
            api,
            data,
            query,
            searchParams,
            _args4 = arguments;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                getData = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
                headers = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                config = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {};
                _this$interceptData = this.interceptData(getApi, getData, config), api = _this$interceptData.api, data = _this$interceptData.data;

                if (isEmpty(data)) {
                  query = '';
                } else if (this.commonConfig.isGetParamJsonStringfy) {
                  query = "?json=".concat(encodeURIComponent(JSON.stringify(data)));
                } else {
                  // https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams
                  searchParams = new URLSearchParams();
                  Object.keys(data).forEach(function (key) {
                    searchParams.append(key, data[key]);
                  });
                  query = "?".concat(searchParams.toString());
                }

                return _context4.abrupt("return", this.requestCache("".concat(api).concat(query), {
                  method: 'GET'
                }, headers, config));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function get(_x4) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(postApi) {
        var postData,
            customeHeaders,
            config,
            _this$interceptData2,
            api,
            data,
            csrfToken,
            headers,
            body,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                postData = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
                customeHeaders = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};
                config = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : {};
                _this$interceptData2 = this.interceptData(postApi, postData, config), api = _this$interceptData2.api, data = _this$interceptData2.data;
                _context5.next = 6;
                return this.getCsrfToken();

              case 6:
                csrfToken = _context5.sent;
                headers = _objectSpread2({
                  'content-type': 'application/json',
                  'x-csrf-token': csrfToken
                }, customeHeaders);
                body = JSON.stringify(data);
                return _context5.abrupt("return", this.requestCache(api, {
                  method: 'POST',
                  headers: headers,
                  body: body
                }, {}, config));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function post(_x5) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(deleteApi) {
        var postData,
            customeHeaders,
            config,
            _this$interceptData3,
            api,
            data,
            csrfToken,
            headers,
            body,
            _args6 = arguments;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                postData = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                customeHeaders = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {};
                config = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : {};
                _this$interceptData3 = this.interceptData(deleteApi, postData, config), api = _this$interceptData3.api, data = _this$interceptData3.data;
                _context6.next = 6;
                return this.getCsrfToken();

              case 6:
                csrfToken = _context6.sent;
                headers = _objectSpread2({
                  'content-type': 'application/json',
                  'x-csrf-token': csrfToken
                }, customeHeaders);
                body = JSON.stringify(data);
                return _context6.abrupt("return", this.requestCache(api, {
                  method: 'DELETE',
                  headers: headers,
                  body: body
                }, {}, config));

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _delete(_x6) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
  }, {
    key: "put",
    value: function () {
      var _put = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(putApi) {
        var postData,
            customeHeaders,
            config,
            _this$interceptData4,
            api,
            data,
            csrfToken,
            headers,
            body,
            _args7 = arguments;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                postData = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                customeHeaders = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};
                config = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : {};
                _this$interceptData4 = this.interceptData(putApi, postData, config), api = _this$interceptData4.api, data = _this$interceptData4.data;
                _context7.next = 6;
                return this.getCsrfToken();

              case 6:
                csrfToken = _context7.sent;
                headers = _objectSpread2({
                  'content-type': 'application/json',
                  'x-csrf-token': csrfToken
                }, customeHeaders);
                body = JSON.stringify(data);
                return _context7.abrupt("return", this.requestCache(api, {
                  method: 'PUT',
                  headers: headers,
                  body: body
                }, {}, config));

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function put(_x7) {
        return _put.apply(this, arguments);
      }

      return put;
    }()
  }, {
    key: "form",
    value: function () {
      var _form = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(formApi, formData) {
        var customeHeaders,
            config,
            _this$interceptData5,
            api,
            data,
            csrfToken,
            headers,
            body,
            _args8 = arguments;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                customeHeaders = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {};
                config = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {};
                _this$interceptData5 = this.interceptData(formApi, formData, config), api = _this$interceptData5.api, data = _this$interceptData5.data;
                _context8.next = 5;
                return this.getCsrfToken();

              case 5:
                csrfToken = _context8.sent;
                headers = _objectSpread2({
                  'x-csrf-token': csrfToken
                }, customeHeaders);
                body = data instanceof FormData ? data : this.objectToFormData(data);
                return _context8.abrupt("return", this.requestCache(api, {
                  method: 'POST',
                  headers: headers,
                  body: body
                }, {}, config));

              case 9:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function form(_x8, _x9) {
        return _form.apply(this, arguments);
      }

      return form;
    }()
  }, {
    key: "config",
    set: function set(_commonConfig) {
      this.commonConfig = _objectSpread2(_objectSpread2(_objectSpread2({}, this.commonConfig), _commonConfig || {}), {}, {
        codeMessage: _objectSpread2(_objectSpread2({}, this.commonConfig.codeMessage), (_commonConfig === null || _commonConfig === void 0 ? void 0 : _commonConfig.codeMessage) || {})
      });
    }
  }]);

  return Http;
}();
var http = new Http();

var request$1 = http.request;
var get$1 = http.get;
var post$1 = http.post;
var deleteMethod$1 = http.delete;
var put$1 = http.put;
var form$1 = http.form;

var parseKey = function parseKey(key) {
  var method = 'get';
  var path = key;

  if (key.indexOf(' ') > -1) {
    var splited = key.split(' ');
    method = splited[0].toLowerCase(); // eslint-disable-next-line prefer-destructuring

    path = splited[1];
  }

  return {
    method: method,
    path: path
  };
};

var gen = function gen(param, library) {
  var _parseKey = parseKey(param),
      method = _parseKey.method,
      path = _parseKey.path;

  return function (data, headers, config) {
    if (isFunction(library)) {
      return library({
        method: method,
        path: path,
        data: data,
        headers: headers,
        header: headers,
        config: config
      });
    }

    if (isObject(library) && isFunction(library[method])) {
      return library[method](path, data, headers, config);
    }

    return function () {
      console.warn("No library found, params are : ".concat({
        method: method,
        path: path,
        data: data,
        headers: headers,
        config: config
      }));
      return null;
    };
  };
};

var genAPI = function genAPI(api, library) {
  var API = {};
  Object.keys(api).forEach(function (apiKey) {
    API[apiKey] = gen(api[apiKey], library);
  });
  return API;
};

var getAPI = function getAPI(api) {
  return genAPI(api, http);
};

var generateAPI = function generateAPI(api) {
  return genAPI(api, axiosMethods);
};

export { adjustToPage, axios, deleteMethod as axiosDelete, form as axiosForm, get as axiosGet, axiosMethods, post as axiosPost, put as axiosPut, base, bind, classnames, console2, ctrlMetaToString, debounce, deleteMethod$1 as deleteMethod, downloadFile, forEach, form$1 as form, fullScreen, genAPI, generateAPI, get$1 as get, getAPI, getDifferentiation, getJS, getLoginPage, getOS, getStyle, highlightText, http, isArray, isBlob, isCtrlMetaPress, isFile, isFormData, isFunction, isMatchKey, isObject, isStream, isString, jsonp, keyboardMan, loadScripts, loadStyles, merge, objToParams, objectToFormData, omitNil, post$1 as post, postPage, printImg, put$1 as put, replacePlaceholder, request$1 as request, setAxiosOptions, stringToDomElement, throttle, urlAddParams, urlParseParams, useAdvancedCompare, useCompare, useDifferentiation, useEventListener, useHistory, usePrevious, usePreviousProp, useWhyDidYouUpdate };
